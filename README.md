task2:

    task2_1:
    Вычислить по методу Ньютона корень квадратный из числа x,
    находящимся во входном потоке (использовался цикл, в котором 
    считывался каждый элемент последовательности, который
    впоследствии обрабатывался методом Ньютона для вычисления корня
    квадратного)

    task2_2_1:
    По заданной последовательности чисел, вычислить многочлен
    n-ой степени по схеме Горнера (для данной задачи использовался
    аналогичный task2_1 алгоритм, только вычисления производились
    по схеме Горнера)

    task2_2_2:
    По заданной последовательности чисел, вычислить многочлен
    n-ой степени по схеме Горнера, а также посчитать производную 
    (аналогичное решение task2_2_1, только с производной)

    task2_2_3:
    По заданной последовательности чисел, вычислить многочлен
    n-ой степени по схеме Горнера, а также посчитать интеграл
    (использовался алгоритм  
        integral *= x;
        integral += b*x/(n+1);
        n -= 1;
    где b - i-й коэффициент посл-ти, 
    n - степень многочлена для i-й итерации, integral - итоговая сумма(интеграл), 
    x - точка)
	
    task2_3:
    Описать рекурсивную и итеративную версии функции i-го
    члена Фибоначчи (функция Fib1, зависящая от i-го эл-та посл-ти
    считает i-е число Фибоначчи итеративно, а функция Fib2, зависящая
    от итогового эл-та посл-ти, считает i-е число Фибоначчи рекурсивно)

    task2_4:
    Описать функцию, преобразующую вещественную константу, 
    заданную строкой, в тип double (осуществлена единственная функция
    str2double, на вход которой подается массив типа char, которая 
    преобразует строку в число)
	
	task2_5:
    Описать тип "список слов"; написать программу, которая
    вводит строку из непустых слов и строит список из этих слов;
    преобразовать список по следующему правилу: удалить все
    слова из списка, совподающие с последним
    (сначала создаём список, затем находим последний элемент в списке 
    и сравниваем каждый элемент с последним, удаляем сначала первые элементы,если они совпадут,
    затем все последующие)
    
	task2_6:
    Описать тип "дерево поиска" с неотрицательными целыми
    ключами; написать программу, которая вводит эл-ты 3-х
    видов:
    +<num>
    -<num>
    ?<num>
    Число с плюсом добавляется в список, если его еще нет
    Число с минусом удаляется из списка, если оно в нем есть
    Число со знаком вопроса ищет элемент и отвечает "yes"
    или "no"
    (tree append(tree t, elemtype n) - функция, добавляющая элемент n в дерево поиска t, если его нет;
    void in_order(tree t) - функция печаетает дерево LKP;
    tree minValueNode(tree t)- функция находит минимальный элемент в правом поддереве и возвращает ссылку на это звено;
    tree delete_elem(tree t, elemtype n) - функция, удаляющая из дерева t элемент n, если он там есть;
    int find(tree t, elemtype n) - функция, которая ищет элемент n в дереве t; 0 - есть в дереве,1 - нет в дереве;
    void delete_tree(tree t) - функция, удаляющая дерево t с освобождением памяти;)

    task2_7:
    К написанной "программе-калькулятор" добавить функции
    умножжения, вычитания и возведения в степень
    (void getlex() - выделяет из входного потока текущую лексему;
    void expr() - распознает выражение и вычисляет его значение;
    void add() - распознает слагаемое и вычисляет его значение;
    void mult() - распознает множитель и вычисляет его значение;
    void error() - сообщает об ошибке в выражении и передает управление в начало функции main(в точку begin))

    Для того, чтобы скомпилировать программы выше и запустить их, 
    достаточно написать следующие команды:
    gcc <program_name> -o <program_name>
    ./<program_name>
	
task3:

    Описать программу, которая, пока не получен конец файла, выполняет 
    в цикле следующие действия:
        1) cчитывает из stdin очередную строку,
        2) преобразует ее в последовательность (список) слов,
        3) выводит в stdout полученную последовательность слов в исходном порядке,
        4) выводит слова последовательности в лексикографическом порядке.
    При выводе в первой строке напечатать длину списка, в каждой последующей – очередной элемент списка.
    Задача была решена путем разбития на 2 подпрограммы: functions.c(в 
    которой описаны все функции, требующиеся для решения задачи) и
    main.c(обрабатывающая stdin)

    functions.c состоит из следующих функций:
        - void clearlist() - удаляет все звенья списка с освобождением памяти
        - void null_list() - задает начальные установки для списка
        - void termlist() - добавляет в список последний "NULL" элемент
        - void nullbuf() - очищает буфер и задает начальные установки
        - void addsym() - добавляет очередной символ в буфер
        - void addword() - добавляет слово из буфера в список
        - void printlist() - печатает список
        - int symset(int c) - определяет специальный символ
        - void sortinglist() - сортирует список в лексикографическом порядке
    
    Для того, чтобы скомпилировать программу и запустить ее была
    использована утилита make, для этого был создан файл Makefile,
    расположенный в директории с программой, следующие команды
    компилируют и запускают прoграмму соответственно:
    make all или просто make
	./a.out
task4:

    Нужно реализовать несколько команд Unix. Команды, обязательные для реализации:
    1. echo – печатает свои аргументы через пробел, возможны флаги (см. man echo). 
    2. pwd – напечатать имя текущего каталога.
    3. ls – вывести список файлов текущего каталога.(Возможны флаги:
    -R – вывести имена всех файлов текущего каталога, а также файлов, содержащихся во вложенных подкаталогах,
    -l – показать атрибуты: тип, права доступа, имя владельца, размер,
    -g – показать имя группы владельца.)
    Далее необходимо реализовать одну команду из группы по выбору, мои команды:
    1. mv old_file new_file 
        (аргументы могут быть каталогами)
    2. grep substring filename
        Результат: строки файла filename, содержащие substring как подстроку (возможен флаг - v; 
        в этом случае результат – это строки, которые не содержат substring как подстроку).
    3. cat filenames
        Возможен флаг:
        -n – с нумерацией строк (если файлов несколько, то нумерация сквозная)
    Каждая команды реализована в отдельном файле, названном в честь самой команды.
    Чтобы скомпилировать программу можно воспользоваться Makefile и запусить make {команда}, 
    далее в командной строке ввести ./{команда} {необходимые аргументы для команды}
task 6:
    
    «Обедающие философы»
    Пять философов гуляют по саду и размышляют, время от времени заходя в беседку (столовую) подкрепиться 
        — там круглый стол с пятью стульями и блюдом спагетти в центре стола. 
    Спагетти длинные и скользкие — чтобы их кушать, нужны две вилки. 
    На столе всего пять вилок. Места философов фиксированы: i-й философ садится на i-й стул. 
    Когда философ садится за стол, он должен взять левую вилку, если она свободна 
    (иначе ждать пока сосед слева поест и положит вилку), взять правую вилку (если она занята, подождать), 
        затем покушать с помощью двух вилок, положить левую и правую вилки и пойти в сад продолжить размышления.
     Исключить возможность тупиковой ситуации, когда все философы сели за стол и взяли левую вилку.
    
    Чтобы скомпилировать программу можно воспользоваться Makefile и запусить: make  далее make run или ./philosophers
task7:

    Задача: Освоить клиент-серверную модель взаимодействия процессов, основанную на сокетах.
    
    Базовая модель
    • Процесс-сервер:
        o создает "слушающий" сокет и ждет запросов на соединение от клиентов;
        o приняв запрос – создает сыновний процесс/поток, который должен обслужить клиента и завершиться, 
            а процесс-отец продолжает принимать запросы на соединение и создавать новых сыновей/потоки.
    • Процесс-сын (обслуживание клиента) – получить от процесса-клиента данные, обработать их и вернуть клиенту, 
        после чего завершиться – возможна обработка нескольких порций данных от клиента вплоть 
            до получения от клиента команды на завершение.
    • Процесс-клиент запрашивает у пользователя данные, отправляет их серверу (адрес сервера можно задать в командной строке,
         или спросить у пользователя), получает от сервера ответ, выполняет преобразования 
            (или некие действия, например, печать на экран).
    
    Вариант 1 (*) – Калькулятор 1.
    
    Процесс-сервер – создает "слушающий" сокет и ждет запросов на соединение от клиентов. 
    Приняв запрос, процесс-сервер создает сыновний процесс, который должен обслужить клиента и завершиться, 
        а процесс-отец продолжает принимать запросы на соединение и создавать новых
    сыновей
    
    Задача сына (обслуживание) – выполнять возможные команды от клиента:
        1) \+ <число> – установить число на которое сервер будет увеличивать числа для данного клиента (по умолчанию 1), вернуть клиенту “Ok”;
        2) <число> – запрос на увеличение числа от клиента, задача – увеличить данное число на заданное и вернуть клиенту;
        3) \? – получить от сервера число, на которое тот увеличивает числа для текущего клиента;
        4) \- – сообщить серверу о завершении работы, при этом сервер-сын завершается
    Программа-клиент:
        1) запрашивает у пользователя очередную команду, отправляет ее серверу (адрес сервера можно задать в командной строке (передаются в main() через argv), или спросить у
            пользователя первым действием;
        2) получает от сервера ответ и печатает его на экран.

    Для реализации задания было написано 2 программы server.c и client.c
    Чтобы запустить сервер можно воспользоваться Makefile : make server
    Чтобы запустить клиента можно воспользоваться Makefile : make client
    Далее сервер будет получать команды от клиента и выполнять их.
task8:

    Цель – реализовать и протестировать новый класс, представляющий абстрактный тип данных, 
    т.е. такой, пользователи которого могут обращаться только к публичным операциям, 
    предусмотренными создателем класса, и не имеют информации о внутреннем его устройстве.
    Средство – язык С++
    Пользователем (клиентом) класса считается не "пользователь программы" или "компьютерный пользователь" 
    вообще, а программист, использующий ваш класс для решения своих задач, пишущий свою программу 
    на его основе. Иногда также под пользователями класса понимаются другие классы, 
    фрагменты программ, которые пользуются его услугами.
    Программа должна быть представлена минимум тремя файлами:
    • <АТД>.h – объявлено все, что необходимо включить в программу, для использования вашего класса АТД,
    • <АТД>.cpp – реализации нетривиальных методов класса,
    • main.cpp – пользовательский интерфейс для тестирования.

    Вариант 4. Вещественная матрица
    Вещественным числом считается число типа double. 
    Необходимо реализовать вещественную матрицу – понятие линейной алгебры. 
    Нужно обеспечить пользователя класса естественным интерфейсом математических операций 
    для работы с матрицами и составления вычислительных программ.
    Для удобства тестирования и отладки ввести строковое представление матрицы, 
    похожее на инициализатор двумерного массива. 
    Так, строка "{{1, 0, 0}, {0, 1, 0.5}}" обозначает матрицу размера 2 ́3:
    
    Вариант 4.1 
    Обязательные операции:
    1) matrix( int n, int m ) – конструктор матрицы размера n ́m со значениями 0.0;
    2) matrix( double ) – матрица 1 ́1 с этим элементом;
    3) matrix( double*, int m ) – матрица-строка из массива длины m;
    4) matrix( int n, double* ) – матрица-столбец из массива длины n;
    5) matrix( char*) – из строкового представления (см. выше);
    6) static matrix matrix::identity( int n ) – возвращает единичную матрицу размера n;
    7) static matrix matrix::diagonal( double* vals, int n ) – возвращает диагональную матрицу размера n с заданными
    элементами по главной диагонали;
    8) int matrix::rows() – число строк;
    9) int matrix::columns() – число столбцов;
    10) matrix::set( int i, int j, double val ) – присвоить значение элементу [i][j];
    11) matrix matrix::matrix[ i ] – i-я строка в виде новой матрицы, если такая строка есть – 1-й приоритет
    12) matrix matrix::matrix[ j ] – j-й столбец в виде новой матрицы, если такой столбец есть – 2-й приоритет, –
    иначе ошибка (если M – матрица, то M[i] – матрица из одной строки, а М[i][j] – матрица 1 ́1 из одного элемента);
    13) matrix * scalar и matrix*=scalar – умножение матрицы на скаляр;
    14) перегрузка операции << – вывод матрицы, в привычном двумерном виде.

    Для компиляции проекта использовался make. 
    Для сборки проекта: make test 
    Для очистки объектных файлов: make clean